Terminals unused in grammar

   AUTO
   BREAK
   CASE
   CONST
   CONTINUE
   DEFAULT
   DO
   ELSE
   ENUM
   EXTERN
   FOR
   IF
   REGISTER
   RETURN
   SIZEOF
   STATIC
   STRUCT
   SWITCH
   TYPEDEF
   UNION
   VOLATILE
   WHILE
   ADD_ASSIGN
   SUB_ASSIGN
   MUL_ASSIGN
   DIV_ASSIGN
   MOD_ASSGIN
   RIGHT_ASSIGN
   LEFT_ASSIGN
   AND_ASSIGN
   XOR_ASSIGN
   OR_ASSIGN
   INC_OP
   DEC_OP
   EQ_OP
   GE_OP
   LE_OP
   OR_OP
   AND_OP
   LEFT_OP
   RIGHT_OP
   PTR_OP
   NE_OP
   IDENTIFIER
   FLOAT_NUM
   HEX_NUM
   INT_NUM


Grammar

    0 $accept: ROOT $end

    1 ROOT: TYPE_SPECIFIER

    2 TYPE_SPECIFIER: VOID
    3               | CHAR
    4               | SHORT
    5               | INT
    6               | LONG
    7               | FLOAT
    8               | DOUBLE
    9               | SIGNED
   10               | UNSIGNED


Terminals, with rules where they appear

$end (0) 0
error (256)
AUTO (258)
BREAK (259)
CASE (260)
CHAR (261) 3
CONST (262)
CONTINUE (263)
DEFAULT (264)
DO (265)
DOUBLE (266) 8
ELSE (267)
ENUM (268)
EXTERN (269)
FLOAT (270) 7
FOR (271)
IF (272)
INT (273) 5
LONG (274) 6
REGISTER (275)
RETURN (276)
SHORT (277) 4
SIGNED (278) 9
UNSIGNED (279) 10
SIZEOF (280)
STATIC (281)
STRUCT (282)
SWITCH (283)
TYPEDEF (284)
UNION (285)
VOID (286) 2
VOLATILE (287)
WHILE (288)
ADD_ASSIGN (289)
SUB_ASSIGN (290)
MUL_ASSIGN (291)
DIV_ASSIGN (292)
MOD_ASSGIN (293)
RIGHT_ASSIGN (294)
LEFT_ASSIGN (295)
AND_ASSIGN (296)
XOR_ASSIGN (297)
OR_ASSIGN (298)
INC_OP (299)
DEC_OP (300)
EQ_OP (301)
GE_OP (302)
LE_OP (303)
OR_OP (304)
AND_OP (305)
LEFT_OP (306)
RIGHT_OP (307)
PTR_OP (308)
NE_OP (309)
IDENTIFIER (310)
FLOAT_NUM (311)
HEX_NUM (312)
INT_NUM (313)


Nonterminals, with rules where they appear

$accept (59)
    on left: 0
ROOT (60)
    on left: 1, on right: 0
TYPE_SPECIFIER (61)
    on left: 2 3 4 5 6 7 8 9 10, on right: 1


State 0

    0 $accept: . ROOT $end

    CHAR      shift, and go to state 1
    DOUBLE    shift, and go to state 2
    FLOAT     shift, and go to state 3
    INT       shift, and go to state 4
    LONG      shift, and go to state 5
    SHORT     shift, and go to state 6
    SIGNED    shift, and go to state 7
    UNSIGNED  shift, and go to state 8
    VOID      shift, and go to state 9

    ROOT            go to state 10
    TYPE_SPECIFIER  go to state 11


State 1

    3 TYPE_SPECIFIER: CHAR .

    $default  reduce using rule 3 (TYPE_SPECIFIER)


State 2

    8 TYPE_SPECIFIER: DOUBLE .

    $default  reduce using rule 8 (TYPE_SPECIFIER)


State 3

    7 TYPE_SPECIFIER: FLOAT .

    $default  reduce using rule 7 (TYPE_SPECIFIER)


State 4

    5 TYPE_SPECIFIER: INT .

    $default  reduce using rule 5 (TYPE_SPECIFIER)


State 5

    6 TYPE_SPECIFIER: LONG .

    $default  reduce using rule 6 (TYPE_SPECIFIER)


State 6

    4 TYPE_SPECIFIER: SHORT .

    $default  reduce using rule 4 (TYPE_SPECIFIER)


State 7

    9 TYPE_SPECIFIER: SIGNED .

    $default  reduce using rule 9 (TYPE_SPECIFIER)


State 8

   10 TYPE_SPECIFIER: UNSIGNED .

    $default  reduce using rule 10 (TYPE_SPECIFIER)


State 9

    2 TYPE_SPECIFIER: VOID .

    $default  reduce using rule 2 (TYPE_SPECIFIER)


State 10

    0 $accept: ROOT . $end

    $end  shift, and go to state 12


State 11

    1 ROOT: TYPE_SPECIFIER .

    $default  reduce using rule 1 (ROOT)


State 12

    0 $accept: ROOT $end .

    $default  accept
