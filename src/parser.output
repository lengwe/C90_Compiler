Nonterminals useless in grammar

   primary_expression
   postfix_expression
   argument_expression_list
   unary_expression
   unary_operator
   cast_expression
   multiplicative_expression
   additive_expression
   shift_expression
   relational_expression
   equality_expression
   and_expression
   exclusive_or_expression
   inclusive_or_expression
   logical_and_expression
   logical_or_expression
   conditional_expression
   assignment_expression
   assignment_operator
   expression
   constant_expression
   init_declarator_list
   init_declarator
   initializer
   type_name
   type_qualifier


Terminals unused in grammar

   BREAK
   CASE
   CONTINUE
   DEFAULT
   DO
   ELSE
   ENUM
   FOR
   IF
   RETURN
   SIZEOF
   STRUCT
   SWITCH
   WHILE
   ADD_ASSIGN
   SUB_ASSIGN
   MUL_ASSIGN
   DIV_ASSIGN
   MOD_ASSIGN
   RIGHT_ASSIGN
   LEFT_ASSIGN
   AND_ASSIGN
   XOR_ASSIGN
   OR_ASSIGN
   INC_OP
   DEC_OP
   EQ_OP
   GE_OP
   LE_OP
   OR_OP
   AND_OP
   LEFT_OP
   RIGHT_OP
   PTR_OP
   NE_OP
   FLOAT_NUM
   HEX_NUM
   INT_NUM
   CHAR_CONSTANT
   CONSTANT
   MOD_ASSGIN
   STRING_LITERAL
   '*'
   '+'
   '-'
   '~'
   '!'
   '&'
   '='
   '['
   ']'
   '('
   ')'
   '.'
   ','
   '/'
   '%'
   '<'
   '>'
   '^'
   '|'
   '?'
   ':'


Rules useless in grammar

   36 primary_expression: IDENTIFIER
   37                   | CONSTANT
   38                   | STRING_LITERAL

   39 postfix_expression: primary_expression
   40                   | postfix_expression '[' expression ']'
   41                   | postfix_expression '(' ')'
   42                   | postfix_expression '(' argument_expression_list ')'
   43                   | postfix_expression '.' IDENTIFIER
   44                   | postfix_expression PTR_OP IDENTIFIER
   45                   | postfix_expression INC_OP
   46                   | postfix_expression DEC_OP

   47 argument_expression_list: assignment_expression
   48                         | argument_expression_list ',' assignment_expression

   49 unary_expression: postfix_expression
   50                 | INC_OP unary_expression
   51                 | DEC_OP unary_expression
   52                 | unary_operator cast_expression
   53                 | SIZEOF unary_expression
   54                 | SIZEOF '(' type_name ')'

   55 unary_operator: '&'
   56               | '*'
   57               | '+'
   58               | '-'
   59               | '~'
   60               | '!'

   61 cast_expression: unary_expression
   62                | '(' type_name ')' cast_expression

   63 multiplicative_expression: cast_expression
   64                          | multiplicative_expression '*' cast_expression
   65                          | multiplicative_expression '/' cast_expression
   66                          | multiplicative_expression '%' cast_expression

   67 additive_expression: multiplicative_expression
   68                    | additive_expression '+' multiplicative_expression
   69                    | additive_expression '-' multiplicative_expression

   70 shift_expression: additive_expression
   71                 | shift_expression LEFT_OP additive_expression
   72                 | shift_expression RIGHT_OP additive_expression

   73 relational_expression: shift_expression
   74                      | relational_expression '<' shift_expression
   75                      | relational_expression '>' shift_expression
   76                      | relational_expression LE_OP shift_expression
   77                      | relational_expression GE_OP shift_expression

   78 equality_expression: relational_expression
   79                    | equality_expression EQ_OP relational_expression
   80                    | equality_expression NE_OP relational_expression

   81 and_expression: equality_expression
   82               | and_expression '&' equality_expression

   83 exclusive_or_expression: and_expression
   84                        | exclusive_or_expression '^' and_expression

   85 inclusive_or_expression: exclusive_or_expression
   86                        | inclusive_or_expression '|' exclusive_or_expression

   87 logical_and_expression: inclusive_or_expression
   88                       | logical_and_expression AND_OP inclusive_or_expression

   89 logical_or_expression: logical_and_expression
   90                      | logical_or_expression OR_OP logical_and_expression

   91 conditional_expression: logical_or_expression
   92                       | logical_or_expression '?' expression ':' conditional_expression

   93 assignment_expression: conditional_expression
   94                      | unary_expression assignment_operator assignment_expression

   95 assignment_operator: '='
   96                    | MUL_ASSIGN
   97                    | DIV_ASSIGN
   98                    | MOD_ASSIGN
   99                    | ADD_ASSIGN
  100                    | SUB_ASSIGN
  101                    | LEFT_ASSIGN
  102                    | RIGHT_ASSIGN
  103                    | AND_ASSIGN
  104                    | XOR_ASSIGN
  105                    | OR_ASSIGN

  106 expression: assignment_expression
  107           | expression ',' assignment_expression

  108 constant_expression: conditional_expression

  109 init_declarator_list: init_declarator
  110                     | init_declarator_list ',' init_declarator

  111 init_declarator: declarator
  112                | declarator '=' initializer

  113 initializer: %empty

  114 type_name: %empty

  115 type_qualifier: %empty


Rules useless in parser due to conflicts

   31 declaration_list: %empty

   33 declaration: %empty

   35 struct_or_union: %empty


State 0 conflicts: 12 shift/reduce, 15 reduce/reduce
State 15 conflicts: 12 shift/reduce, 2 reduce/reduce
State 16 conflicts: 12 shift/reduce, 15 reduce/reduce
State 18 conflicts: 12 shift/reduce, 2 reduce/reduce
State 21 conflicts: 15 reduce/reduce
State 25 conflicts: 15 reduce/reduce
State 31 conflicts: 1 shift/reduce


Grammar

    0 $accept: ROOT $end

    1 ROOT: translation_unit

    2 declaration_specifiers: storage_class_specifier
    3                       | storage_class_specifier declaration_specifiers
    4                       | type_specifier
    5                       | type_specifier declaration_specifiers

    6 storage_class_specifier: TYPEDEF
    7                        | STATIC
    8                        | AUTO

    9 translation_unit: external_declaration
   10                 | translation_unit external_declaration

   11 external_declaration: function_definition
   12                     | declaration

   13 type_specifier: VOID
   14               | CHAR
   15               | SHORT
   16               | INT
   17               | LONG
   18               | FLOAT
   19               | DOUBLE
   20               | SIGNED
   21               | UNSIGNED
   22               | struct_or_union_specifier

   23 struct_or_union_specifier: struct_or_union IDENTIFIER '{' struct_declaration_list '}'
   24                          | struct_or_union '{' struct_declaration_list '}'
   25                          | struct_or_union IDENTIFIER

   26 function_definition: declaration_specifiers declarator declaration_list compound_statement
   27                    | declaration_specifiers declarator compound_statement
   28                    | declarator declaration_list compound_statement
   29                    | declarator compound_statement

   30 compound_statement: %empty

   31 declaration_list: %empty

   32 declarator: %empty

   33 declaration: %empty

   34 struct_declaration_list: %empty

   35 struct_or_union: %empty


Terminals, with rules where they appear

$end (0) 0
'!' (33)
'%' (37)
'&' (38)
'(' (40)
')' (41)
'*' (42)
'+' (43)
',' (44)
'-' (45)
'.' (46)
'/' (47)
':' (58)
'<' (60)
'=' (61)
'>' (62)
'?' (63)
'[' (91)
']' (93)
'^' (94)
'{' (123) 23 24
'|' (124)
'}' (125) 23 24
'~' (126)
error (256)
AUTO (258) 8
BREAK (259)
CASE (260)
CHAR (261) 14
CONTINUE (262)
DEFAULT (263)
DO (264)
DOUBLE (265) 19
ELSE (266)
ENUM (267)
FLOAT (268) 18
FOR (269)
IF (270)
INT (271) 16
LONG (272) 17
RETURN (273)
SHORT (274) 15
SIGNED (275) 20
UNSIGNED (276) 21
SIZEOF (277)
STATIC (278) 7
STRUCT (279)
SWITCH (280)
TYPEDEF (281) 6
VOID (282) 13
WHILE (283)
ADD_ASSIGN (284)
SUB_ASSIGN (285)
MUL_ASSIGN (286)
DIV_ASSIGN (287)
MOD_ASSIGN (288)
RIGHT_ASSIGN (289)
LEFT_ASSIGN (290)
AND_ASSIGN (291)
XOR_ASSIGN (292)
OR_ASSIGN (293)
INC_OP (294)
DEC_OP (295)
EQ_OP (296)
GE_OP (297)
LE_OP (298)
OR_OP (299)
AND_OP (300)
LEFT_OP (301)
RIGHT_OP (302)
PTR_OP (303)
NE_OP (304)
IDENTIFIER (305) 23 25
FLOAT_NUM (306)
HEX_NUM (307)
INT_NUM (308)
CHAR_CONSTANT (309)
CONSTANT (310)
MOD_ASSGIN (311)
STRING_LITERAL (312)


Nonterminals, with rules where they appear

$accept (81)
    on left: 0
ROOT (82)
    on left: 1, on right: 0
declaration_specifiers (83)
    on left: 2 3 4 5, on right: 3 5 26 27
storage_class_specifier (84)
    on left: 6 7 8, on right: 2 3
translation_unit (85)
    on left: 9 10, on right: 1 10
external_declaration (86)
    on left: 11 12, on right: 9 10
type_specifier (87)
    on left: 13 14 15 16 17 18 19 20 21 22, on right: 4 5
struct_or_union_specifier (88)
    on left: 23 24 25, on right: 22
function_definition (89)
    on left: 26 27 28 29, on right: 11
compound_statement (90)
    on left: 30, on right: 26 27 28 29
declaration_list (91)
    on left: 31, on right: 26 28
declarator (92)
    on left: 32, on right: 26 27 28 29
declaration (93)
    on left: 33, on right: 12
struct_declaration_list (94)
    on left: 34, on right: 23 24
struct_or_union (95)
    on left: 35, on right: 23 24 25


State 0

    0 $accept: . ROOT $end

    AUTO      shift, and go to state 1
    CHAR      shift, and go to state 2
    DOUBLE    shift, and go to state 3
    FLOAT     shift, and go to state 4
    INT       shift, and go to state 5
    LONG      shift, and go to state 6
    SHORT     shift, and go to state 7
    SIGNED    shift, and go to state 8
    UNSIGNED  shift, and go to state 9
    STATIC    shift, and go to state 10
    TYPEDEF   shift, and go to state 11
    VOID      shift, and go to state 12

    $end        reduce using rule 32 (declarator)
    $end        [reduce using rule 33 (declaration)]
    AUTO        [reduce using rule 32 (declarator)]
    AUTO        [reduce using rule 33 (declaration)]
    CHAR        [reduce using rule 32 (declarator)]
    CHAR        [reduce using rule 33 (declaration)]
    DOUBLE      [reduce using rule 32 (declarator)]
    DOUBLE      [reduce using rule 33 (declaration)]
    FLOAT       [reduce using rule 32 (declarator)]
    FLOAT       [reduce using rule 33 (declaration)]
    INT         [reduce using rule 32 (declarator)]
    INT         [reduce using rule 33 (declaration)]
    LONG        [reduce using rule 32 (declarator)]
    LONG        [reduce using rule 33 (declaration)]
    SHORT       [reduce using rule 32 (declarator)]
    SHORT       [reduce using rule 33 (declaration)]
    SIGNED      [reduce using rule 32 (declarator)]
    SIGNED      [reduce using rule 33 (declaration)]
    UNSIGNED    [reduce using rule 32 (declarator)]
    UNSIGNED    [reduce using rule 33 (declaration)]
    STATIC      [reduce using rule 32 (declarator)]
    STATIC      [reduce using rule 33 (declaration)]
    TYPEDEF     [reduce using rule 32 (declarator)]
    TYPEDEF     [reduce using rule 33 (declaration)]
    VOID        [reduce using rule 32 (declarator)]
    VOID        [reduce using rule 33 (declaration)]
    IDENTIFIER  reduce using rule 32 (declarator)
    IDENTIFIER  [reduce using rule 33 (declaration)]
    IDENTIFIER  [reduce using rule 35 (struct_or_union)]
    '{'         reduce using rule 32 (declarator)
    '{'         [reduce using rule 33 (declaration)]
    '{'         [reduce using rule 35 (struct_or_union)]
    $default    reduce using rule 32 (declarator)

    ROOT                       go to state 13
    declaration_specifiers     go to state 14
    storage_class_specifier    go to state 15
    translation_unit           go to state 16
    external_declaration       go to state 17
    type_specifier             go to state 18
    struct_or_union_specifier  go to state 19
    function_definition        go to state 20
    declarator                 go to state 21
    declaration                go to state 22
    struct_or_union            go to state 23


State 1

    8 storage_class_specifier: AUTO .

    $default  reduce using rule 8 (storage_class_specifier)


State 2

   14 type_specifier: CHAR .

    $default  reduce using rule 14 (type_specifier)


State 3

   19 type_specifier: DOUBLE .

    $default  reduce using rule 19 (type_specifier)


State 4

   18 type_specifier: FLOAT .

    $default  reduce using rule 18 (type_specifier)


State 5

   16 type_specifier: INT .

    $default  reduce using rule 16 (type_specifier)


State 6

   17 type_specifier: LONG .

    $default  reduce using rule 17 (type_specifier)


State 7

   15 type_specifier: SHORT .

    $default  reduce using rule 15 (type_specifier)


State 8

   20 type_specifier: SIGNED .

    $default  reduce using rule 20 (type_specifier)


State 9

   21 type_specifier: UNSIGNED .

    $default  reduce using rule 21 (type_specifier)


State 10

    7 storage_class_specifier: STATIC .

    $default  reduce using rule 7 (storage_class_specifier)


State 11

    6 storage_class_specifier: TYPEDEF .

    $default  reduce using rule 6 (storage_class_specifier)


State 12

   13 type_specifier: VOID .

    $default  reduce using rule 13 (type_specifier)


State 13

    0 $accept: ROOT . $end

    $end  shift, and go to state 24


State 14

   26 function_definition: declaration_specifiers . declarator declaration_list compound_statement
   27                    | declaration_specifiers . declarator compound_statement

    $default  reduce using rule 32 (declarator)

    declarator  go to state 25


State 15

    2 declaration_specifiers: storage_class_specifier .
    3                       | storage_class_specifier . declaration_specifiers

    AUTO      shift, and go to state 1
    CHAR      shift, and go to state 2
    DOUBLE    shift, and go to state 3
    FLOAT     shift, and go to state 4
    INT       shift, and go to state 5
    LONG      shift, and go to state 6
    SHORT     shift, and go to state 7
    SIGNED    shift, and go to state 8
    UNSIGNED  shift, and go to state 9
    STATIC    shift, and go to state 10
    TYPEDEF   shift, and go to state 11
    VOID      shift, and go to state 12

    AUTO        [reduce using rule 2 (declaration_specifiers)]
    CHAR        [reduce using rule 2 (declaration_specifiers)]
    DOUBLE      [reduce using rule 2 (declaration_specifiers)]
    FLOAT       [reduce using rule 2 (declaration_specifiers)]
    INT         [reduce using rule 2 (declaration_specifiers)]
    LONG        [reduce using rule 2 (declaration_specifiers)]
    SHORT       [reduce using rule 2 (declaration_specifiers)]
    SIGNED      [reduce using rule 2 (declaration_specifiers)]
    UNSIGNED    [reduce using rule 2 (declaration_specifiers)]
    STATIC      [reduce using rule 2 (declaration_specifiers)]
    TYPEDEF     [reduce using rule 2 (declaration_specifiers)]
    VOID        [reduce using rule 2 (declaration_specifiers)]
    IDENTIFIER  reduce using rule 2 (declaration_specifiers)
    IDENTIFIER  [reduce using rule 35 (struct_or_union)]
    '{'         reduce using rule 2 (declaration_specifiers)
    '{'         [reduce using rule 35 (struct_or_union)]
    $default    reduce using rule 2 (declaration_specifiers)

    declaration_specifiers     go to state 26
    storage_class_specifier    go to state 15
    type_specifier             go to state 18
    struct_or_union_specifier  go to state 19
    struct_or_union            go to state 23


State 16

    1 ROOT: translation_unit .
   10 translation_unit: translation_unit . external_declaration

    AUTO      shift, and go to state 1
    CHAR      shift, and go to state 2
    DOUBLE    shift, and go to state 3
    FLOAT     shift, and go to state 4
    INT       shift, and go to state 5
    LONG      shift, and go to state 6
    SHORT     shift, and go to state 7
    SIGNED    shift, and go to state 8
    UNSIGNED  shift, and go to state 9
    STATIC    shift, and go to state 10
    TYPEDEF   shift, and go to state 11
    VOID      shift, and go to state 12

    $end        reduce using rule 1 (ROOT)
    $end        [reduce using rule 32 (declarator)]
    $end        [reduce using rule 33 (declaration)]
    AUTO        [reduce using rule 32 (declarator)]
    AUTO        [reduce using rule 33 (declaration)]
    CHAR        [reduce using rule 32 (declarator)]
    CHAR        [reduce using rule 33 (declaration)]
    DOUBLE      [reduce using rule 32 (declarator)]
    DOUBLE      [reduce using rule 33 (declaration)]
    FLOAT       [reduce using rule 32 (declarator)]
    FLOAT       [reduce using rule 33 (declaration)]
    INT         [reduce using rule 32 (declarator)]
    INT         [reduce using rule 33 (declaration)]
    LONG        [reduce using rule 32 (declarator)]
    LONG        [reduce using rule 33 (declaration)]
    SHORT       [reduce using rule 32 (declarator)]
    SHORT       [reduce using rule 33 (declaration)]
    SIGNED      [reduce using rule 32 (declarator)]
    SIGNED      [reduce using rule 33 (declaration)]
    UNSIGNED    [reduce using rule 32 (declarator)]
    UNSIGNED    [reduce using rule 33 (declaration)]
    STATIC      [reduce using rule 32 (declarator)]
    STATIC      [reduce using rule 33 (declaration)]
    TYPEDEF     [reduce using rule 32 (declarator)]
    TYPEDEF     [reduce using rule 33 (declaration)]
    VOID        [reduce using rule 32 (declarator)]
    VOID        [reduce using rule 33 (declaration)]
    IDENTIFIER  reduce using rule 32 (declarator)
    IDENTIFIER  [reduce using rule 33 (declaration)]
    IDENTIFIER  [reduce using rule 35 (struct_or_union)]
    '{'         reduce using rule 32 (declarator)
    '{'         [reduce using rule 33 (declaration)]
    '{'         [reduce using rule 35 (struct_or_union)]
    $default    reduce using rule 32 (declarator)

    declaration_specifiers     go to state 14
    storage_class_specifier    go to state 15
    external_declaration       go to state 27
    type_specifier             go to state 18
    struct_or_union_specifier  go to state 19
    function_definition        go to state 20
    declarator                 go to state 21
    declaration                go to state 22
    struct_or_union            go to state 23


State 17

    9 translation_unit: external_declaration .

    $default  reduce using rule 9 (translation_unit)


State 18

    4 declaration_specifiers: type_specifier .
    5                       | type_specifier . declaration_specifiers

    AUTO      shift, and go to state 1
    CHAR      shift, and go to state 2
    DOUBLE    shift, and go to state 3
    FLOAT     shift, and go to state 4
    INT       shift, and go to state 5
    LONG      shift, and go to state 6
    SHORT     shift, and go to state 7
    SIGNED    shift, and go to state 8
    UNSIGNED  shift, and go to state 9
    STATIC    shift, and go to state 10
    TYPEDEF   shift, and go to state 11
    VOID      shift, and go to state 12

    AUTO        [reduce using rule 4 (declaration_specifiers)]
    CHAR        [reduce using rule 4 (declaration_specifiers)]
    DOUBLE      [reduce using rule 4 (declaration_specifiers)]
    FLOAT       [reduce using rule 4 (declaration_specifiers)]
    INT         [reduce using rule 4 (declaration_specifiers)]
    LONG        [reduce using rule 4 (declaration_specifiers)]
    SHORT       [reduce using rule 4 (declaration_specifiers)]
    SIGNED      [reduce using rule 4 (declaration_specifiers)]
    UNSIGNED    [reduce using rule 4 (declaration_specifiers)]
    STATIC      [reduce using rule 4 (declaration_specifiers)]
    TYPEDEF     [reduce using rule 4 (declaration_specifiers)]
    VOID        [reduce using rule 4 (declaration_specifiers)]
    IDENTIFIER  reduce using rule 4 (declaration_specifiers)
    IDENTIFIER  [reduce using rule 35 (struct_or_union)]
    '{'         reduce using rule 4 (declaration_specifiers)
    '{'         [reduce using rule 35 (struct_or_union)]
    $default    reduce using rule 4 (declaration_specifiers)

    declaration_specifiers     go to state 28
    storage_class_specifier    go to state 15
    type_specifier             go to state 18
    struct_or_union_specifier  go to state 19
    struct_or_union            go to state 23


State 19

   22 type_specifier: struct_or_union_specifier .

    $default  reduce using rule 22 (type_specifier)


State 20

   11 external_declaration: function_definition .

    $default  reduce using rule 11 (external_declaration)


State 21

   28 function_definition: declarator . declaration_list compound_statement
   29                    | declarator . compound_statement

    $end        reduce using rule 30 (compound_statement)
    $end        [reduce using rule 31 (declaration_list)]
    AUTO        reduce using rule 30 (compound_statement)
    AUTO        [reduce using rule 31 (declaration_list)]
    CHAR        reduce using rule 30 (compound_statement)
    CHAR        [reduce using rule 31 (declaration_list)]
    DOUBLE      reduce using rule 30 (compound_statement)
    DOUBLE      [reduce using rule 31 (declaration_list)]
    FLOAT       reduce using rule 30 (compound_statement)
    FLOAT       [reduce using rule 31 (declaration_list)]
    INT         reduce using rule 30 (compound_statement)
    INT         [reduce using rule 31 (declaration_list)]
    LONG        reduce using rule 30 (compound_statement)
    LONG        [reduce using rule 31 (declaration_list)]
    SHORT       reduce using rule 30 (compound_statement)
    SHORT       [reduce using rule 31 (declaration_list)]
    SIGNED      reduce using rule 30 (compound_statement)
    SIGNED      [reduce using rule 31 (declaration_list)]
    UNSIGNED    reduce using rule 30 (compound_statement)
    UNSIGNED    [reduce using rule 31 (declaration_list)]
    STATIC      reduce using rule 30 (compound_statement)
    STATIC      [reduce using rule 31 (declaration_list)]
    TYPEDEF     reduce using rule 30 (compound_statement)
    TYPEDEF     [reduce using rule 31 (declaration_list)]
    VOID        reduce using rule 30 (compound_statement)
    VOID        [reduce using rule 31 (declaration_list)]
    IDENTIFIER  reduce using rule 30 (compound_statement)
    IDENTIFIER  [reduce using rule 31 (declaration_list)]
    '{'         reduce using rule 30 (compound_statement)
    '{'         [reduce using rule 31 (declaration_list)]
    $default    reduce using rule 30 (compound_statement)

    compound_statement  go to state 29
    declaration_list    go to state 30


State 22

   12 external_declaration: declaration .

    $default  reduce using rule 12 (external_declaration)


State 23

   23 struct_or_union_specifier: struct_or_union . IDENTIFIER '{' struct_declaration_list '}'
   24                          | struct_or_union . '{' struct_declaration_list '}'
   25                          | struct_or_union . IDENTIFIER

    IDENTIFIER  shift, and go to state 31
    '{'         shift, and go to state 32


State 24

    0 $accept: ROOT $end .

    $default  accept


State 25

   26 function_definition: declaration_specifiers declarator . declaration_list compound_statement
   27                    | declaration_specifiers declarator . compound_statement

    $end        reduce using rule 30 (compound_statement)
    $end        [reduce using rule 31 (declaration_list)]
    AUTO        reduce using rule 30 (compound_statement)
    AUTO        [reduce using rule 31 (declaration_list)]
    CHAR        reduce using rule 30 (compound_statement)
    CHAR        [reduce using rule 31 (declaration_list)]
    DOUBLE      reduce using rule 30 (compound_statement)
    DOUBLE      [reduce using rule 31 (declaration_list)]
    FLOAT       reduce using rule 30 (compound_statement)
    FLOAT       [reduce using rule 31 (declaration_list)]
    INT         reduce using rule 30 (compound_statement)
    INT         [reduce using rule 31 (declaration_list)]
    LONG        reduce using rule 30 (compound_statement)
    LONG        [reduce using rule 31 (declaration_list)]
    SHORT       reduce using rule 30 (compound_statement)
    SHORT       [reduce using rule 31 (declaration_list)]
    SIGNED      reduce using rule 30 (compound_statement)
    SIGNED      [reduce using rule 31 (declaration_list)]
    UNSIGNED    reduce using rule 30 (compound_statement)
    UNSIGNED    [reduce using rule 31 (declaration_list)]
    STATIC      reduce using rule 30 (compound_statement)
    STATIC      [reduce using rule 31 (declaration_list)]
    TYPEDEF     reduce using rule 30 (compound_statement)
    TYPEDEF     [reduce using rule 31 (declaration_list)]
    VOID        reduce using rule 30 (compound_statement)
    VOID        [reduce using rule 31 (declaration_list)]
    IDENTIFIER  reduce using rule 30 (compound_statement)
    IDENTIFIER  [reduce using rule 31 (declaration_list)]
    '{'         reduce using rule 30 (compound_statement)
    '{'         [reduce using rule 31 (declaration_list)]
    $default    reduce using rule 30 (compound_statement)

    compound_statement  go to state 33
    declaration_list    go to state 34


State 26

    3 declaration_specifiers: storage_class_specifier declaration_specifiers .

    $default  reduce using rule 3 (declaration_specifiers)


State 27

   10 translation_unit: translation_unit external_declaration .

    $default  reduce using rule 10 (translation_unit)


State 28

    5 declaration_specifiers: type_specifier declaration_specifiers .

    $default  reduce using rule 5 (declaration_specifiers)


State 29

   29 function_definition: declarator compound_statement .

    $default  reduce using rule 29 (function_definition)


State 30

   28 function_definition: declarator declaration_list . compound_statement

    $default  reduce using rule 30 (compound_statement)

    compound_statement  go to state 35


State 31

   23 struct_or_union_specifier: struct_or_union IDENTIFIER . '{' struct_declaration_list '}'
   25                          | struct_or_union IDENTIFIER .

    '{'  shift, and go to state 36

    '{'       [reduce using rule 25 (struct_or_union_specifier)]
    $default  reduce using rule 25 (struct_or_union_specifier)


State 32

   24 struct_or_union_specifier: struct_or_union '{' . struct_declaration_list '}'

    $default  reduce using rule 34 (struct_declaration_list)

    struct_declaration_list  go to state 37


State 33

   27 function_definition: declaration_specifiers declarator compound_statement .

    $default  reduce using rule 27 (function_definition)


State 34

   26 function_definition: declaration_specifiers declarator declaration_list . compound_statement

    $default  reduce using rule 30 (compound_statement)

    compound_statement  go to state 38


State 35

   28 function_definition: declarator declaration_list compound_statement .

    $default  reduce using rule 28 (function_definition)


State 36

   23 struct_or_union_specifier: struct_or_union IDENTIFIER '{' . struct_declaration_list '}'

    $default  reduce using rule 34 (struct_declaration_list)

    struct_declaration_list  go to state 39


State 37

   24 struct_or_union_specifier: struct_or_union '{' struct_declaration_list . '}'

    '}'  shift, and go to state 40


State 38

   26 function_definition: declaration_specifiers declarator declaration_list compound_statement .

    $default  reduce using rule 26 (function_definition)


State 39

   23 struct_or_union_specifier: struct_or_union IDENTIFIER '{' struct_declaration_list . '}'

    '}'  shift, and go to state 41


State 40

   24 struct_or_union_specifier: struct_or_union '{' struct_declaration_list '}' .

    $default  reduce using rule 24 (struct_or_union_specifier)


State 41

   23 struct_or_union_specifier: struct_or_union IDENTIFIER '{' struct_declaration_list '}' .

    $default  reduce using rule 23 (struct_or_union_specifier)
