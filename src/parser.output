Nonterminals useless in grammar

   primary_expression
   postfix_expression
   argument_expression_list
   unary_expression
   unary_operator
   cast_expression
   multiplicative_expression
   additive_expression
   shift_expression
   relational_expression
   equality_expression
   and_expression
   exclusive_or_expression
   inclusive_or_expression
   logical_and_expression
   logical_or_expression
   conditional_expression
   assignment_expression
   assignment_operator
   expression
   constant_expression
   declaration_specifiers
   init_declarator_list
   init_declarator
   storage_class_specifier
   translation_unit
   external_declaration
   function_definition
   compound_statement
   declaration_list
   declarator
   declaration
   initializer
   struct_declaration_list
   struct_or_union
   type_name
   type_qualifier


Terminals unused in grammar

   AUTO
   BREAK
   CASE
   CONTINUE
   DEFAULT
   DO
   ELSE
   ENUM
   FOR
   IF
   RETURN
   SIZEOF
   STATIC
   STRUCT
   SWITCH
   TYPEDEF
   WHILE
   CONST
   ADD_ASSIGN
   SUB_ASSIGN
   MUL_ASSIGN
   DIV_ASSIGN
   MOD_ASSIGN
   RIGHT_ASSIGN
   LEFT_ASSIGN
   AND_ASSIGN
   XOR_ASSIGN
   OR_ASSIGN
   INC_OP
   DEC_OP
   EQ_OP
   GE_OP
   LE_OP
   OR_OP
   AND_OP
   LEFT_OP
   RIGHT_OP
   PTR_OP
   NE_OP
   IDENTIFIER
   FLOAT_NUM
   HEX_NUM
   INT_NUM
   CHAR_CONSTANT
   CONSTANT
   MOD_ASSGIN
   STRING_LITERAL
   '*'
   '+'
   '-'
   '~'
   '!'
   '&'
   '='
   '['
   ']'
   '('
   ')'
   '.'
   ','
   '/'
   '%'
   '<'
   '>'
   '^'
   '|'
   '?'
   ':'


Rules useless in grammar

   13 primary_expression: IDENTIFIER
   14                   | CONSTANT
   15                   | STRING_LITERAL

   16 postfix_expression: primary_expression
   17                   | postfix_expression '[' expression ']'
   18                   | postfix_expression '(' ')'
   19                   | postfix_expression '(' argument_expression_list ')'
   20                   | postfix_expression '.' IDENTIFIER
   21                   | postfix_expression PTR_OP IDENTIFIER
   22                   | postfix_expression INC_OP
   23                   | postfix_expression DEC_OP

   24 argument_expression_list: assignment_expression
   25                         | argument_expression_list ',' assignment_expression

   26 unary_expression: postfix_expression
   27                 | INC_OP unary_expression
   28                 | DEC_OP unary_expression
   29                 | unary_operator cast_expression
   30                 | SIZEOF unary_expression
   31                 | SIZEOF '(' type_name ')'

   32 unary_operator: '&'
   33               | '*'
   34               | '+'
   35               | '-'
   36               | '~'
   37               | '!'

   38 cast_expression: unary_expression
   39                | '(' type_name ')' cast_expression

   40 multiplicative_expression: cast_expression
   41                          | multiplicative_expression '*' cast_expression
   42                          | multiplicative_expression '/' cast_expression
   43                          | multiplicative_expression '%' cast_expression

   44 additive_expression: multiplicative_expression
   45                    | additive_expression '+' multiplicative_expression
   46                    | additive_expression '-' multiplicative_expression

   47 shift_expression: additive_expression
   48                 | shift_expression LEFT_OP additive_expression
   49                 | shift_expression RIGHT_OP additive_expression

   50 relational_expression: shift_expression
   51                      | relational_expression '<' shift_expression
   52                      | relational_expression '>' shift_expression
   53                      | relational_expression LE_OP shift_expression
   54                      | relational_expression GE_OP shift_expression

   55 equality_expression: relational_expression
   56                    | equality_expression EQ_OP relational_expression
   57                    | equality_expression NE_OP relational_expression

   58 and_expression: equality_expression
   59               | and_expression '&' equality_expression

   60 exclusive_or_expression: and_expression
   61                        | exclusive_or_expression '^' and_expression

   62 inclusive_or_expression: exclusive_or_expression
   63                        | inclusive_or_expression '|' exclusive_or_expression

   64 logical_and_expression: inclusive_or_expression
   65                       | logical_and_expression AND_OP inclusive_or_expression

   66 logical_or_expression: logical_and_expression
   67                      | logical_or_expression OR_OP logical_and_expression

   68 conditional_expression: logical_or_expression
   69                       | logical_or_expression '?' expression ':' conditional_expression

   70 assignment_expression: conditional_expression
   71                      | unary_expression assignment_operator assignment_expression

   72 assignment_operator: '='
   73                    | MUL_ASSIGN
   74                    | DIV_ASSIGN
   75                    | MOD_ASSIGN
   76                    | ADD_ASSIGN
   77                    | SUB_ASSIGN
   78                    | LEFT_ASSIGN
   79                    | RIGHT_ASSIGN
   80                    | AND_ASSIGN
   81                    | XOR_ASSIGN
   82                    | OR_ASSIGN

   83 expression: assignment_expression
   84           | expression ',' assignment_expression

   85 constant_expression: conditional_expression

   86 declaration_specifiers: storage_class_specifier
   87                       | storage_class_specifier declaration_specifiers
   88                       | type_specifier
   89                       | type_specifier declaration_specifiers

   90 init_declarator_list: init_declarator
   91                     | init_declarator_list ',' init_declarator

   92 init_declarator: declarator
   93                | declarator '=' initializer

   94 storage_class_specifier: TYPEDEF
   95                        | STATIC
   96                        | AUTO

   97 translation_unit: external_declaration
   98                 | translation_unit external_declaration

   99 external_declaration: function_definition
  100                     | declaration

  101 function_definition: declaration_specifiers declarator declaration_list compound_statement
  102                    | declaration_specifiers declarator compound_statement
  103                    | declarator declaration_list compound_statement
  104                    | declarator compound_statement

  105 compound_statement: %empty

  106 declaration_list: %empty

  107 declarator: %empty

  108 declaration: %empty

  109 initializer: %empty

  110 struct_declaration_list: %empty

  111 struct_or_union: %empty

  112 type_name: %empty

  113 type_qualifier: %empty


Grammar

    0 $accept: ROOT $end

    1 ROOT: type_specifier

    2 type_specifier: VOID
    3               | CHAR
    4               | SHORT
    5               | INT
    6               | LONG
    7               | FLOAT
    8               | DOUBLE
    9               | SIGNED
   10               | UNSIGNED
   11               | struct_or_union_specifier

   12 struct_or_union_specifier: %empty


Terminals, with rules where they appear

$end (0) 0
'!' (33)
'%' (37)
'&' (38)
'(' (40)
')' (41)
'*' (42)
'+' (43)
',' (44)
'-' (45)
'.' (46)
'/' (47)
':' (58)
'<' (60)
'=' (61)
'>' (62)
'?' (63)
'[' (91)
']' (93)
'^' (94)
'|' (124)
'~' (126)
error (256)
AUTO (258)
BREAK (259)
CASE (260)
CHAR (261) 3
CONTINUE (262)
DEFAULT (263)
DO (264)
DOUBLE (265) 8
ELSE (266)
ENUM (267)
FLOAT (268) 7
FOR (269)
IF (270)
INT (271) 5
LONG (272) 6
RETURN (273)
SHORT (274) 4
SIGNED (275) 9
UNSIGNED (276) 10
SIZEOF (277)
STATIC (278)
STRUCT (279)
SWITCH (280)
TYPEDEF (281)
VOID (282) 2
WHILE (283)
CONST (284)
ADD_ASSIGN (285)
SUB_ASSIGN (286)
MUL_ASSIGN (287)
DIV_ASSIGN (288)
MOD_ASSIGN (289)
RIGHT_ASSIGN (290)
LEFT_ASSIGN (291)
AND_ASSIGN (292)
XOR_ASSIGN (293)
OR_ASSIGN (294)
INC_OP (295)
DEC_OP (296)
EQ_OP (297)
GE_OP (298)
LE_OP (299)
OR_OP (300)
AND_OP (301)
LEFT_OP (302)
RIGHT_OP (303)
PTR_OP (304)
NE_OP (305)
IDENTIFIER (306)
FLOAT_NUM (307)
HEX_NUM (308)
INT_NUM (309)
CHAR_CONSTANT (310)
CONSTANT (311)
MOD_ASSGIN (312)
STRING_LITERAL (313)


Nonterminals, with rules where they appear

$accept (80)
    on left: 0
ROOT (81)
    on left: 1, on right: 0
type_specifier (82)
    on left: 2 3 4 5 6 7 8 9 10 11, on right: 1
struct_or_union_specifier (83)
    on left: 12, on right: 11


State 0

    0 $accept: . ROOT $end

    CHAR      shift, and go to state 1
    DOUBLE    shift, and go to state 2
    FLOAT     shift, and go to state 3
    INT       shift, and go to state 4
    LONG      shift, and go to state 5
    SHORT     shift, and go to state 6
    SIGNED    shift, and go to state 7
    UNSIGNED  shift, and go to state 8
    VOID      shift, and go to state 9

    $default  reduce using rule 12 (struct_or_union_specifier)

    ROOT                       go to state 10
    type_specifier             go to state 11
    struct_or_union_specifier  go to state 12


State 1

    3 type_specifier: CHAR .

    $default  reduce using rule 3 (type_specifier)


State 2

    8 type_specifier: DOUBLE .

    $default  reduce using rule 8 (type_specifier)


State 3

    7 type_specifier: FLOAT .

    $default  reduce using rule 7 (type_specifier)


State 4

    5 type_specifier: INT .

    $default  reduce using rule 5 (type_specifier)


State 5

    6 type_specifier: LONG .

    $default  reduce using rule 6 (type_specifier)


State 6

    4 type_specifier: SHORT .

    $default  reduce using rule 4 (type_specifier)


State 7

    9 type_specifier: SIGNED .

    $default  reduce using rule 9 (type_specifier)


State 8

   10 type_specifier: UNSIGNED .

    $default  reduce using rule 10 (type_specifier)


State 9

    2 type_specifier: VOID .

    $default  reduce using rule 2 (type_specifier)


State 10

    0 $accept: ROOT . $end

    $end  shift, and go to state 13


State 11

    1 ROOT: type_specifier .

    $default  reduce using rule 1 (ROOT)


State 12

   11 type_specifier: struct_or_union_specifier .

    $default  reduce using rule 11 (type_specifier)


State 13

    0 $accept: ROOT $end .

    $default  accept
